## ✒ 未来版本的新特性 (Features in future versions)

### v0.4.x

* 日志器带有默认的结构化数据，以及 With 的实现
* 考虑自己写时间格式化，标准库的时间格式化耗费的时间和内存都很多
* 尝试和 Context 机制结合，传递信息
* 缓冲写出器增加分段锁机制增加并发性能
* 按时间、文件大小自动切割日志文件
* 重新支持配置文件

### v0.3.x

经过一段时间的实际使用，发现了一些不太方便的地方需要进行调整。

* Handler 的设计太过于抽象，导致很多日志库本身的功能实现过于剥离、插件化
* 类 Json 的配置文件容易嵌套过多，不方便看（这也是 Handler 抽象程度太高导致的）
* 部分 API 使用不太方便，特别是和 Handler 相关的一些功能
* 有些 API 的使用频率确实很低，原本已经屏蔽了一些，但目前的 API 列表还不够清爽
* duration 和 size 的设计导致没办法同时使用，而且加新特性会越来越臃肿
* 加入日志存活天数的特性
* 加入日志存活个数的特性
* ~~使用多个变量替代 map，避免哈希消耗性能~~
  > 这么做还是无法避免一层映射，如果真的要避免映射，就得对 log 方法进行比较大幅度的改造。

> 总结：原本让我引以为傲的 Handler 在长期的使用下来发现很蛋疼，
> 优点是有，但麻烦也不少，所以需要改造！

### v0.0.x - v0.2.x

* 实现基础的日志功能
* ~~引入 RollinHook 组件~~
  > 取消这个特性是因为，它的代码入侵太严重了，并且会使代码设计变得很复杂，使用体验也会变差。
  > 为了这样一个扩展特性要去改动核心特性的代码，有些喧宾夺主了，所以最后取消了这个组件。
* ~~修复配置文件中出现转义字符导致解析出错的问题~~
  > 取消这个特性是因为，配置文件是用户写的，如果存在转义字符的问题，用户自行做转义会更适合一点。
* ~~增加 timeout_handler.go，里面是带超时功能的日志处理器包装器~~
  > 取消这个特性是因为，一般在需要获取某个执行时间很长甚至可能一直阻塞的操作的结果时才需要超时，
  > 对于日志输出而言，我们并不需要获取日志输出操作的结果，所以这个特性意义不大。
  > 还有一个原因就是，实现超时需要使用并发，在超时的任务里终止某个任务，
  > 而 Go 语言并没有提供可以停止并销毁一个 goroutine 的方法，所以即使超时了，也没有办法终止这个任务
  > 甚至可能造成 goroutine 的阻塞。综合上述，取消这个超时功能的日志处理器包装器。
* ~~结合上面几点，以 “并发、缓冲” 为特点进行设计，技术使用 writer 接口进行包装~~
  > 取消这个特性是因为，经过实验，性能并没有改善多少，两个方案，一个是使用队列进行缓冲，
  > 开启一个 Go 协程写出数据，一个是不缓冲，直接开启多个 Go 协程进行写出数据。
  > 第一个方案中，性能反而下降了一倍，估计和内存分配有关，最重要的就是，如果队列还有缓冲数据，
  > 但是程序崩了，就有可能导致数据丢失，日志往往就需要最新最后的数据，而丢失的也正是最新最后的数据，
  > 所以这个方案直接否决。第二个方案中，性能几乎没有提升，而且导致日志输出的顺序不固定，也有可能丢失。
  > 综合上述，取消这个并发化日志输出的特性。
* ~~给日志输出增加颜色显示~~
  > 取消颜色是因为考虑到线上生产环境主要使用文件，这个终端颜色显示的特性不是这么必须。
  > 如果要实现，还要针对不同的操作系统处理，代价大于价值，所以废弃这个新特性。